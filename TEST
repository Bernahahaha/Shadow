-- ======================= Load Libraries =======================
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- ======================= GUI Setup =======================
local guiWidth, guiHeight = 460, 300
local Window = Fluent:CreateWindow({
    Title = "ShadowCore " .. Fluent.Version,
    SubTitle = "by Sin",
    TabWidth = 160,
    Size = UDim2.fromOffset(guiWidth, guiHeight),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})
local Options = Fluent.Options

-- ======================= Tabs =======================
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "home" }),
   Automation = Window:AddTab({ Title = "Automation", Icon = "cog" }),
    Fun = Window:AddTab({ Title = "Fun", Icon = "smile" }),
    AutoBandage = Window:AddTab({ Title = "Auto Bandage", Icon = "heart" }),
    BringStuff = Window:AddTab({ Title = "Bring Stuff", Icon = "hand" }),
    LocalPlayer = Window:AddTab({ Title = "Local Player", Icon = "user" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "arrow-up-right" }),
    Visuals = Window:AddTab({ Title = "Visuals", Icon = "eye" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

-- ======================= Main Tab =======================
Tabs.Main:AddParagraph({
    Title = "Credits",
    Content = "GUI made by Sin\nRoblox: MIJ_LIM2021 Sin\nDiscord: https://discord.gg/vBEFRWTP"
})

Tabs.Main:AddButton({
    Title = "Join My Discord",
    Description = "Click to join my Discord server",
    Callback = function()
        setclipboard("https://discord.gg/vBEFRWTP")
        Fluent:Notify({
            Title = "Discord Link Copied",
            Content = "Invite link copied to clipboard!",
            Duration = 5
        })
    end
})

-- ======================= Automation Tab =======================
Tabs.Automation:AddParagraph({Title = "Automation", Content = "Here you can enable general automation features."})

-- ======================= Fun Tab (Merged) =======================
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local StarterGui = game:GetService("StarterGui")
    local Lighting = game:GetService("Lighting")
    local LocalPlayer = Players.LocalPlayer

    local function getRoot()
        local char = LocalPlayer.Character
        if char then return char:FindFirstChild("HumanoidRootPart") end
        return nil
    end

    -- Spin Player
    Tabs.Fun:AddButton({
        Title = "Spin Player",
        Description = "Spin your character like a Beyblade!",
        Callback = function()
            local root = getRoot()
            if not root then return end
            for i = 1, 50 do
                task.wait()
                root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(30), 0)
            end
        end
    })

    -- Launch Into Sky
    Tabs.Fun:AddButton({
        Title = "Launch Into Sky",
        Description = "Send yourself flying up!",
        Callback = function()
            local root = getRoot()
            if root then root.Velocity = Vector3.new(0, 200, 0) end
        end
    })

    -- Fake Kill (Troll)
    Tabs.Fun:AddButton({
        Title = "Fake Kill (Troll)",
        Description = "Pretend to die then auto-respawn",
        Callback = function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("Humanoid") then
                char.Humanoid.Health = 0
                task.delay(1, function()
                    LocalPlayer:LoadCharacter()
                end)
            end
        end
    })

    -- Earthquake View (toggle)
    local earthquakeEnabled = false
    Tabs.Fun:AddToggle("EarthquakeToggle", {
        Title = "Earthquake View",
        Description = "Shake your camera like an earthquake",
        Default = false,
        Callback = function(state) earthquakeEnabled = state end
    })
    RunService.RenderStepped:Connect(function()
        if earthquakeEnabled and workspace.CurrentCamera then
            local cam = workspace.CurrentCamera
            cam.CFrame = cam.CFrame * CFrame.Angles(
                math.rad(math.random(-2, 2)),
                math.rad(math.random(-2, 2)),
                0
            )
        end
    end)

    -- Random Teleport
    Tabs.Fun:AddButton({
        Title = "Random Teleport",
        Description = "Teleport to a random spot in the map",
        Callback = function()
            local root = getRoot()
            if root then
                local randPos = Vector3.new(math.random(-500, 500), 10, math.random(-500, 500))
                root.CFrame = CFrame.new(randPos)
            end
        end
    })

    -- Flip Over
    Tabs.Fun:AddButton({
        Title = "Flip Over",
        Description = "Turns your character upside down",
        Callback = function()
            local root = getRoot()
            if root then
                root.CFrame = root.CFrame * CFrame.Angles(math.rad(180), 0, 0)
            end
        end
    })

    -- Backflip (single)
    Tabs.Fun:AddButton({
        Title = "Backflip",
        Description = "Do a backflip animation",
        Callback = function()
            local root = getRoot()
            if not root then return end
            for i = 1, 36 do
                task.wait(0.02)
                root.CFrame = root.CFrame * CFrame.Angles(math.rad(-10), 0, 0)
            end
        end
    })

    -- Backflip Loop (toggle)
    local backflipLoop = false
    Tabs.Fun:AddToggle("BackflipLoop", {
        Title = "Backflip Loop",
        Description = "Keep doing backflips until toggled off",
        Default = false,
        Callback = function(state)
            backflipLoop = state
            task.spawn(function()
                while backflipLoop do
                    local root = getRoot()
                    if not root then break end
                    for i = 1, 36 do
                        if not backflipLoop then break end
                        task.wait(0.02)
                        root.CFrame = root.CFrame * CFrame.Angles(math.rad(-10), 0, 0)
                    end
                    task.wait(0.2)
                end
            end)
        end
    })

    -- Handstand (2s hold)
    Tabs.Fun:AddButton({
        Title = "Handstand",
        Description = "Flip upside down and hold",
        Callback = function()
            local root = getRoot()
            if not root then return end
            root.CFrame = root.CFrame * CFrame.Angles(math.rad(180), 0, 0)
            task.wait(2)
            root.CFrame = root.CFrame * CFrame.Angles(math.rad(180), 0, 0) -- revert
        end
    })

    -- One-arm Handstand (tilted, 2s hold)
    Tabs.Fun:AddButton({
        Title = "One-arm Handstand",
        Description = "Balance on one arm like a boss",
        Callback = function()
            local root = getRoot()
            if not root then return end
            root.CFrame = root.CFrame * CFrame.Angles(math.rad(180), 0, math.rad(15))
            task.wait(2)
            root.CFrame = root.CFrame * CFrame.Angles(math.rad(180), 0, math.rad(-15)) -- revert
        end
    })

    -- Planche (2s hold)
    Tabs.Fun:AddButton({
        Title = "Planche",
        Description = "Hold yourself parallel to the ground",
        Callback = function()
            local root = getRoot()
            if not root then return end
            root.CFrame = root.CFrame * CFrame.Angles(math.rad(90), 0, 0)
            task.wait(2)
            root.CFrame = root.CFrame * CFrame.Angles(math.rad(-90), 0, 0) -- revert
        end
    })

    -- Ragdoll Mode
    Tabs.Fun:AddButton({
        Title = "Ragdoll Mode",
        Description = "Makes you flop like a ragdoll",
        Callback = function()
            local char = LocalPlayer.Character
            if not char then return end
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("Motor6D") then
                    local socket = Instance.new("BallSocketConstraint")
                    local a1 = Instance.new("Attachment")
                    local a2 = Instance.new("Attachment")
                    a1.Parent = part.Part0
                    a2.Parent = part.Part1
                    socket.Attachment0 = a1
                    socket.Attachment1 = a2
                    socket.Parent = part.Part0
                    part:Destroy()
                end
            end
        end
    })

    -- Fake Chat Spam (client-side only)
    Tabs.Fun:AddButton({
        Title = "Fake Chat Spam",
        Description = "Spam funny messages in YOUR chat (nobody else sees it)",
        Callback = function()
            for i = 1, 10 do
                StarterGui:SetCore("ChatMakeSystemMessage", {
                    Text = "[ShadowCore Troll]: I am under your bed " .. tostring(math.random(1000,9999)),
                    Color = Color3.fromRGB(math.random(0,255), math.random(0,255), math.random(0,255)),
                    Font = Enum.Font.SourceSansBold,
                    FontSize = Enum.FontSize.Size24
                })
                task.wait(0.3)
            end
        end
    })

    -- Crazy Walk (toggle)
    local crazyWalk = false
    Tabs.Fun:AddToggle("CrazyWalkToggle", {
        Title = "Crazy Walk",
        Description = "Your legs go nuts when walking",
        Default = false,
        Callback = function(state) crazyWalk = state end
    })
    RunService.Stepped:Connect(function()
        if crazyWalk then
            local root = getRoot()
            if root then
                root.CFrame = root.CFrame * CFrame.Angles(0, 0, math.rad(math.random(-10, 10)))
            end
        end
    end)

    -- Invert Screen Colors (5s)
    Tabs.Fun:AddButton({
        Title = "Invert Screen Colors",
        Description = "Mess up your vision for 5 seconds",
        Callback = function()
            local invert = Instance.new("ColorCorrectionEffect")
            invert.Name = "SC_InvertColors"
            invert.Contrast = -2
            invert.Brightness = 0.1
            invert.Saturation = -3
            invert.Parent = Lighting
            task.delay(5, function()
                if invert then invert:Destroy() end
            end)
        end
    })

    -- Clown Mode (Ultimate Chaos)
    Tabs.Fun:AddButton({
        Title = "Clown Mode",
        Description = "Spin + crazy walk + earthquake + inverted colors",
        Callback = function()
            earthquakeEnabled = true
            crazyWalk = true
            local invert = Instance.new("ColorCorrectionEffect")
            invert.Name = "SC_ClownInvert"
            invert.Contrast = -2
            invert.Brightness = 0.1
            invert.Saturation = -3
            invert.Parent = Lighting

            local root = getRoot()
            if root then
                for i = 1, 100 do
                    task.wait(0.05)
                    root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(20), 0)
                end
            end

            task.delay(5, function()
                earthquakeEnabled = false
                crazyWalk = false
                if invert then invert:Destroy() end
            end)
        end
    })
end

-- ======================= Auto Bandage Tab =======================
do
    local AutoBandage = Tabs.AutoBandage:AddToggle("AutoBandage", {
        Title = "Auto Bandage",
        Description = "Automatically heals your player.",
        Default = false
    })
    AutoBandage:OnChanged(function(State)
        task.spawn(function()
            while State do
                task.wait(1)
                local player = game.Players.LocalPlayer
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    local humanoid = player.Character.Humanoid
                    if humanoid.Health < humanoid.MaxHealth then
                        humanoid.Health = humanoid.MaxHealth
                        print("Healed player!")
                    end
                end
                if not AutoBandage.Value then break end
            end
        end)
    end)
end

-- ======================= Bring Stuff Tab =======================
Tabs.BringStuff:AddButton({
    Title = "Bring Stuff",
    Description = "Bring all items to your location",
    Callback = function()
        local player = game.Players.LocalPlayer
        local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not root then return end
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name:match("Item") then
                obj.CFrame = root.CFrame + Vector3.new(0,5,0)
                print("Brought object:", obj.Name)
            end
        end
    end
})

-- ======================= Local Player Tab =======================
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local LocalPlayer = Players.LocalPlayer

    -- Walk Speed
    local SpeedValue = 16
    local SpeedSlider = Tabs.LocalPlayer:AddSlider("WalkSpeedSlider", {
        Title = "Walk Speed",
        Description = "Adjust your walking speed",
        Default = 16,
        Min = 16,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            SpeedValue = Value
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = SpeedValue
            end
        end
    })
    LocalPlayer.CharacterAdded:Connect(function(char) char:WaitForChild("Humanoid").WalkSpeed = SpeedValue end)

    -- Infinite Jump
    local InfiniteJumpEnabled = false
    Tabs.LocalPlayer:AddToggle("InfiniteJumpToggle", {
        Title = "Infinite Jump",
        Description = "Jump as many times as you want",
        Default = false,
        Callback = function(State) InfiniteJumpEnabled = State end
    })
    UserInputService.JumpRequest:Connect(function()
        if InfiniteJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end)

    -- NoClip
    local NoClipEnabled = false
    local NoClipConnection
    Tabs.LocalPlayer:AddToggle("NoClipToggle", {
        Title = "No Clip",
        Description = "Walk through walls",
        Default = false,
        Callback = function(State)
            NoClipEnabled = State
            if NoClipEnabled then
                NoClipConnection = RunService.Stepped:Connect(function()
                    if LocalPlayer.Character then
                        for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                            if part:IsA("BasePart") then part.CanCollide = false end
                        end
                    end
                end)
            else
                if NoClipConnection then NoClipConnection:Disconnect() NoClipConnection = nil end
            end
        end
    })

    -- Reset Character
    Tabs.LocalPlayer:AddButton({Title = "Reset Character", Description = "Resets your character", Callback = function()
        if LocalPlayer.Character then LocalPlayer.Character:BreakJoints() print("Character reset!") end
    end})
end

-- ======================= Teleport Tab =======================
do
    Tabs.Teleport:AddInput("TeleportInput", {
        Title = "Teleport To (x,y,z)",
        Default = "0,0,0",
        Placeholder = "Enter coordinates like 0,5,0",
        Callback = function(Value)
            local player = game.Players.LocalPlayer
            local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if root then
                local x, y, z = Value:match("([^,]+),([^,]+),([^,]+)")
                x, y, z = tonumber(x), tonumber(y), tonumber(z)
                if x and y and z then root.CFrame = CFrame.new(x,y,z) print("Teleported to:", x, y, z) else print("Invalid coordinates!") end
            end
        end
    })
    Tabs.Teleport:AddKeybind("TeleportKey", {
        Title = "Teleport Key",
        Mode = "Toggle",
        Default = "F",
        Callback = function()
            local player = game.Players.LocalPlayer
            local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if root then root.CFrame = CFrame.new(0,10,0) print("Teleported to preset location!") end
        end
    })
    Tabs.Teleport:AddButton({
        Title = "Teleport to Camp",
        Description = "Instantly teleport to coordinates 9, 4, -1",
        Callback = function()
            local player = game.Players.LocalPlayer
            local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if root then root.CFrame = CFrame.new(9, 4, -1) print("Teleported to: 9, 4, -1") else warn("Cannot teleport: HumanoidRootPart not found.") end
        end
    })
end

-- ======================= Visuals Tab - ESP Players =======================
do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer
    local PlayerESPEnabled = false
    local ESPPlayers = {}

    local VisualsTab = Tabs.Visuals
    VisualsTab:AddToggle("PlayerESP", {
        Title = "Enable Player ESP",
        Description = "Highlights players with health bar and distance",
        Default = false,
        Callback = function(state)
            PlayerESPEnabled = state
            if not state then
                for _, data in pairs(ESPPlayers) do
                    if data.Billboard then data.Billboard:Destroy() end
                end
                ESPPlayers = {}
            end
        end
    })

    local function CreateESPForPlayer(plr)
        if ESPPlayers[plr] then return end
        if not plr.Character or not plr.Character:FindFirstChild("HumanoidRootPart") then return end
        local hrp = plr.Character.HumanoidRootPart
        local bb = Instance.new("BillboardGui")
        bb.Name = "SC_PlayerESP"
        bb.Adornee = hrp
        bb.Size = UDim2.new(0,120,0,36)
        bb.StudsOffset = Vector3.new(0,2,0)
        bb.AlwaysOnTop = true
        bb.Parent = hrp

        local nameLabel = Instance.new("TextLabel")
        nameLabel.BackgroundTransparency = 1
        nameLabel.Size = UDim2.new(1,0,0.3,0)
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.TextColor3 = Color3.fromRGB(255,255,255)
        nameLabel.TextScaled = true
        nameLabel.Text = plr.Name
        nameLabel.Parent = bb

        local healthBar = Instance.new("Frame")
        healthBar.BackgroundColor3 = Color3.fromRGB(173, 216, 230) -- Light blue
        healthBar.Size = UDim2.new(1,0,0.2,0)
        healthBar.Position = UDim2.new(0,0,0.3,0)
        healthBar.BorderSizePixel = 0
        healthBar.Parent = bb

        local distLabel = Instance.new("TextLabel")
        distLabel.BackgroundTransparency = 1
        distLabel.Size = UDim2.new(1,0,0.3,0)
        distLabel.Position = UDim2.new(0,0,0.5,0)
        distLabel.Font = Enum.Font.Gotham
        distLabel.TextColor3 = Color3.fromRGB(255,255,255)
        distLabel.TextScaled = true
        distLabel.Text = "Distance: 0"
        distLabel.Parent = bb

        ESPPlayers[plr] = {Billboard = bb, HealthBar = healthBar, DistanceLabel = distLabel}
    end

    RunService.RenderStepped:Connect(function()
        if not PlayerESPEnabled then return end
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Humanoid") then
                CreateESPForPlayer(plr)
                local hum = plr.Character.Humanoid
                local data = ESPPlayers[plr]
                if data then
                    local healthRatio = math.clamp(hum.Health / (hum.MaxHealth or 1), 0, 1)
                    data.HealthBar.Size = UDim2.new(healthRatio,0,0.2,0)
                    if healthRatio > 0.6 then
                        data.HealthBar.BackgroundColor3 = Color3.fromRGB(0,255,0)
                    elseif healthRatio > 0.3 then
                        data.HealthBar.BackgroundColor3 = Color3.fromRGB(255,255,0)
                    else
                        data.HealthBar.BackgroundColor3 = Color3.fromRGB(255,0,0)
                    end
                    local dist = (plr.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                    data.DistanceLabel.Text = ("Distance: %.1f"):format(dist)
                    if dist < 20 then
                        data.DistanceLabel.TextColor3 = Color3.fromRGB(0,255,0)
                    elseif dist < 50 then
                        data.DistanceLabel.TextColor3 = Color3.fromRGB(255,255,0)
                    else
                        data.DistanceLabel.TextColor3 = Color3.fromRGB(255,0,0)
                    end
                end
            end
        end
    end)
end

-- ======================= Settings Tab =======================
do
    SaveManager:SetLibrary(Fluent)
    InterfaceManager:SetLibrary(Fluent)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes({})
    InterfaceManager:SetFolder("FluentScriptHub")
    SaveManager:SetFolder("FluentScriptHub/specific-game")
    InterfaceManager:BuildInterfaceSection(Tabs.Settings)
    SaveManager:BuildConfigSection(Tabs.Settings)
end

-- ======================= Advanced Minimize Button (Draggable / Toggle Window) =======================
do
    local CoreGui = game:GetService("CoreGui")
    local UserInputService = game:GetService("UserInputService")
    local RunService = game:GetService("RunService")

    -- Create ScreenGui + Button
    local miniGui = Instance.new("ScreenGui")
    miniGui.Name = "SC_MinimizeButton"
    miniGui.ResetOnSpawn = false
    miniGui.Parent = CoreGui

    local btn = Instance.new("TextButton")
    btn.Name = "MinimizeBtn"
    btn.Size = UDim2.new(0, 140, 0, 34)
    btn.Position = UDim2.new(0, 12, 0.5, -17) -- start at left-middle
    btn.AnchorPoint = Vector2.new(0, 0)
    btn.BackgroundColor3 = Color3.fromRGB(25,25,25)
    btn.BorderSizePixel = 0
    btn.AutoButtonColor = true
    btn.Text = "● ShadowCore" -- dot shows visible status
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 16
    btn.Parent = miniGui

    local statusDot = Instance.new("TextLabel")
    statusDot.Name = "StatusDot"
    statusDot.Size = UDim2.new(0,14,0,14)
    statusDot.Position = UDim2.new(0,8,0,10)
    statusDot.BackgroundTransparency = 1
    statusDot.Text = ""
    statusDot.Parent = btn

    -- Track visibility state (assume visible)
    local windowVisible = true

    -- Helper: try multiple ways to toggle Fluent window visibility
    local function setWindowVisible(vis)
        local success = false
        -- try common API methods
        local ok, _ = pcall(function()
            if type(Window) == "table" and Window.SetVisible then
                Window:SetVisible(vis)
                success = true
            elseif type(Window) == "table" and Window.Hide and Window.Show then
                if vis then Window:Show() else Window:Hide() end
                success = true
            end
        end)
        -- try common instance roots (Enabled/Enabled property or Visible)
        if not success then
            pcall(function()
                -- try a few likely property names on the Window object
                local candidates = { "Root", "Main", "Container", "Window", "UI" }
                for _, name in ipairs(candidates) do
                    if Window[name] and typeof(Window[name]) == "Instance" then
                        local inst = Window[name]
                        if inst:IsA("ScreenGui") and inst.Enabled ~= nil then inst.Enabled = vis success = true break end
                        if inst:IsA("GuiObject") and inst.Visible ~= nil then inst.Visible = vis success = true break end
                    end
                end
            end)
        end
        -- fallback: find any ScreenGui in CoreGui with "Fluent" or "ShadowCore" in its name
        if not success then
            pcall(function()
                for _, g in ipairs(CoreGui:GetChildren()) do
                    if g:IsA("ScreenGui") then
                        local lname = g.Name:lower()
                        if string.find(lname, "fluent") or string.find(lname, "shadowcore") then
                            if g.Enabled ~= nil then g.Enabled = vis else g.Parent = (vis and CoreGui or nil) end
                            success = true
                            break
                        end
                    end
                end
            end)
        end
        -- as a last resort, try toggling all ScreenGuis named in workspace UI (not ideal)
        if not success then
            pcall(function()
                for _, g in ipairs(CoreGui:GetChildren()) do
                    if g:IsA("ScreenGui") and g.Name:match(".*") then
                        if g.Enabled ~= nil then g.Enabled = vis end
                    end
                end
                success = true
            end)
        end
        windowVisible = vis
        -- update button text/dot
        if windowVisible then
            btn.Text = "● ShadowCore"
            btn.TextColor3 = Color3.fromRGB(255,255,255)
        else
            btn.Text = "○ ShadowCore"
            btn.TextColor3 = Color3.fromRGB(200,200,200)
        end
        return success
    end

    -- initialize state: try to ensure windowVisible = true
    pcall(function() setWindowVisible(true) end)

    -- Click toggles window visibility
    btn.MouseButton1Click:Connect(function()
        setWindowVisible(not windowVisible)
    end)

    -- Dragging logic for the button
    local dragging = false
    local dragInput, dragStart, startPos

    local function updatePosition(input)
        local delta = input.Position - dragStart
        btn.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    btn.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = btn.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        elseif input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = btn.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)

    btn.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            pcall(function() updatePosition(input) end)
        end
    end)

    -- Optional: Right-click to hide the minimize button itself (press again to show via key)
    btn.MouseButton2Click:Connect(function()
        miniGui.Enabled = false
        -- show a small restore hint in the corner so user can get it back with a key
        local hint = Instance.new("TextLabel")
        hint.Name = "SC_MinimizeHint"
        hint.Size = UDim2.new(0,140,0,24)
        hint.Position = UDim2.new(1,-150,0,10)
        hint.BackgroundColor3 = Color3.fromRGB(20,20,20)
        hint.TextColor3 = Color3.fromRGB(255,255,255)
        hint.Text = "Press RightShift to restore SC button"
        hint.Font = Enum.Font.Gotham
        hint.TextSize = 14
        hint.Parent = CoreGui
        delay(6, function() pcall(function() hint:Destroy() end) end)
    end)

    -- Keybind to toggle minimize button visibility (RightShift)
    UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.KeyCode == Enum.KeyCode.RightShift then
            miniGui.Enabled = not miniGui.Enabled
        end
        if input.KeyCode == Enum.KeyCode.LeftShift and not processed then
            -- Extra: LeftShift+Click on button will force-show window
            -- (no-op placeholder, kept so keyboard combos won't break)
        end
    end)

    -- Safety: make sure button stays visible on screen (clamp)
    RunService.RenderStepped:Connect(function()
        if not btn or not btn.Parent then return end
        -- clamp offset so it doesn't go off-screen (best-effort)
        local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920,1080)
        local px = math.clamp(btn.Position.X.Offset, 0, vp.X - btn.AbsoluteSize.X)
        local py = math.clamp(btn.Position.Y.Offset, 0, vp.Y - btn.AbsoluteSize.Y)
        if btn.Position.X.Scale == 0 and btn.Position.Y.Scale == 0 then
            btn.Position = UDim2.new(0, px, 0, py)
        end
    end)
end

-- ======================= Initialize GUI =======================
Window:SelectTab(1)
Fluent:Notify({ Title = "ShadowCore", Content = "The script has been loaded.", Duration = 8 })
SaveManager:LoadAutoloadConfig()
